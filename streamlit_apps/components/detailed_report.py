import streamlit as st
import pandas as pd
from datetime import datetime
import plotly.graph_objects as go
import plotly.express as px
from typing import Dict, List
import base64
from io import BytesIO
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, PageBreak
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.lib import colors
import json
import os

class DetailedReportAgent:
    """
    Agente especializado para generar informes detallados de producci√≥n.
    """
    
    def __init__(self):
        # Cargar prompt desde el archivo en core/prompts
        prompt_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 
                                  'core', 'prompts', 'detailed_report_prompt.md')
        try:
            with open(prompt_path, 'r', encoding='utf-8') as f:
                self.system_prompt = f.read()
        except FileNotFoundError:
            st.error(f"No se encontr√≥ el archivo de prompt: {prompt_path}")
            self.system_prompt = "Error: No se pudo cargar el prompt del informe detallado."
    
    def generate_report(self, df: pd.DataFrame) -> Dict:
        """
        Genera un informe detallado usando el servicio especializado.
        
        Args:
            df: DataFrame con datos de producci√≥n
            
        Returns:
            Dict con el informe estructurado
        """
        
        # Usar el servicio especializado para generar el informe
        from services.detailed_report_service import DetailedReportService
        
        try:
            report_service = DetailedReportService(df)
            report = report_service.generate_detailed_report()
            return report
        except Exception as e:
            st.error(f"Error generando informe: {str(e)}")
            # Fallback a informe b√°sico
            return self._generate_fallback_report(df)
    
    def _generate_fallback_report(self, df: pd.DataFrame) -> Dict:
        """Genera un informe b√°sico como fallback en caso de error."""
        
        # Calcular m√©tricas b√°sicas
        from utils.production_metrics import compute_metric_diferencia_toneladas
        diferencia_toneladas = compute_metric_diferencia_toneladas(df)
        sackoff_total = df['sackoff_por_orden_produccion'].sum() if 'sackoff_por_orden_produccion' in df.columns else 0
        durabilidad_promedio = df['durabilidad_pct_qa_agroindustrial'].mean() if 'durabilidad_pct_qa_agroindustrial' in df.columns else 0
        dureza_promedio = df['dureza_qa_agroindustrial'].mean() if 'dureza_qa_agroindustrial' in df.columns else 0
        finos_promedio = df['finos_pct_qa_agroindustrial'].mean() if 'finos_pct_qa_agroindustrial' in df.columns else 0
        
        return {
            "resumen_ejecutivo": f"Informe b√°sico generado para {len(df)} √≥rdenes de producci√≥n.",
            "analisis_produccion": f"Diferencia de toneladas: {diferencia_toneladas:.1f} toneladas",
            "analisis_calidad": f"Durabilidad promedio: {durabilidad_promedio:.1f}%",
            "analisis_diferencia_toneladas": f"Sackoff total: {sackoff_total:.2f}%",
            "recomendaciones": ["Revisar datos para an√°lisis m√°s detallado"],
            "metricas_clave": {
                "diferencia_toneladas": diferencia_toneladas,
                "sackoff_total": sackoff_total,
                "durabilidad_promedio": durabilidad_promedio,
                "dureza_promedio": dureza_promedio,
                "finos_promedio": finos_promedio,
                "total_ordenes": len(df)
            },
            "comparaciones_temporales": {
                "mes_actual_vs_anterior": {},
                "semana_actual": {}
            },
            "correlaciones": [],
            "tendencias": {},

        }

def create_metric_with_tooltip(title: str, value: str, tooltip_text: str, icon: str = "‚ÑπÔ∏è"):
    """
    Crea una m√©trica con tooltip profesional que se muestra al hacer hover
    
    Args:
        title: T√≠tulo de la m√©trica
        value: Valor de la m√©trica
        tooltip_text: Texto del tooltip
        icon: Icono para el tooltip (por defecto ‚ÑπÔ∏è)
    """
    # Crear el HTML para la m√©trica con tooltip
    html_content = f"""
    <div style="position: relative; display: inline-block; width: 100%;">
        <div style="
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            margin: 0.5rem 0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            border: 1px solid #e9ecef;
            border-left: 5px solid #1C8074;
            transition: all 0.3s ease;
            position: relative;
        ">
            <div style="
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0.5rem;
            ">
                <h4 style="
                    color: #1A494C;
                    margin: 0;
                    font-size: 1rem;
                    font-weight: 600;
                    text-transform: uppercase;
                    letter-spacing: 0.3px;
                ">
                    {title}
                </h4>
                <div style="
                    position: relative;
                    display: inline-block;
                    cursor: help;
                ">
                    <span style="
                        font-size: 1.2rem;
                        color: #666666;
                        opacity: 0.7;
                        transition: opacity 0.3s ease;
                    " 
                    onmouseover="this.style.opacity='1'; this.nextElementSibling.style.display='block';"
                    onmouseout="this.style.opacity='0.7'; this.nextElementSibling.style.display='none';"
                    >
                        {icon}
                    </span>
                    <div style="
                        display: none;
                        position: absolute;
                        bottom: 125%;
                        right: 0;
                        background: #1A494C;
                        color: white;
                        padding: 0.75rem;
                        border-radius: 8px;
                        font-size: 0.85rem;
                        line-height: 1.4;
                        width: 280px;
                        z-index: 1000;
                        box-shadow: 0 4px 20px rgba(0,0,0,0.15);
                        border: 1px solid #1C8074;
                    ">
                        {tooltip_text}
                        <div style="
                            position: absolute;
                            top: 100%;
                            right: 10px;
                            border: 8px solid transparent;
                            border-top-color: #1A494C;
                        "></div>
                    </div>
                </div>
            </div>
            <div style="
                font-size: 2rem;
                font-weight: 700;
                color: #1C8074;
                text-align: center;
                margin-top: 0.5rem;
                text-shadow: 0 1px 2px rgba(0,0,0,0.1);
            ">
                {value}
            </div>
        </div>
    </div>
    """
    
    st.markdown(html_content, unsafe_allow_html=True)

def render_detailed_report_page():
    """Renderiza la p√°gina del informe detallado simplificada."""
    
    st.title("üìä Informe Detallado de Producci√≥n")
    st.markdown("---")
    
    # Cargar datos
    from streamlit_apps.components.data_loader import get_produccion_aliar_data, check_database_service
    
    # Verificar servicio de base de datos
    db_available, db_service = check_database_service()
    
    if not db_available:
        st.error("‚ùå Servicio de base de datos no disponible")
        return
    
    # Obtener datos
    df = get_produccion_aliar_data()
    
    if df is None or df.empty:
        st.error("No se pudieron cargar los datos de producci√≥n. Verifica la conexi√≥n a la base de datos.")
        return
    
    # Inicializar agente
    agent = DetailedReportAgent()
    
    # Bot√≥n de descarga PDF al inicio
    col1, col2, col3 = st.columns([1, 2, 1])
    with col2:
        if st.button("üìÑ Descargar Informe PDF", type="primary", use_container_width=True):
            # Generar informe para PDF
            with st.spinner("üîÑ Generando PDF..."):
                report = agent.generate_report(df)
                if report:
                    pdf_bytes = generate_pdf_report(report)
                    if pdf_bytes:
                        st.download_button(
                            label="‚¨áÔ∏è Descargar PDF",
                            data=pdf_bytes,
                            file_name=f"informe_detallado_{datetime.now().strftime('%Y%m%d_%H%M')}.pdf",
                            mime="application/pdf",
                            use_container_width=True
                        )
                    else:
                        st.error("Error generando PDF")
    
    st.markdown("---")
    
    # Generar informe autom√°ticamente (sin configuraci√≥n visible)
    with st.spinner("üîÑ Generando informe detallado..."):
        report = agent.generate_report(df)
    
    if report:
        # Mostrar informe en una sola hoja
        st.success("‚úÖ Informe generado exitosamente!")
        
        # Resumen Ejecutivo
        st.subheader("üí° Insights")
        st.write(report['resumen_ejecutivo'])
        
        # M√©tricas clave con tooltips profesionales
        st.subheader("üìä KPIs Principales")
        
        col1, col2, col3 = st.columns(3)
        metricas = report['metricas_clave']
        
        with col1:
            st.markdown(f"""
            **DIFERENCIA DE TONELADAS**  
            **{metricas['diferencia_toneladas']:.1f} ton**  
            <span style='color: #1C8074;'>‚öñÔ∏è</span>
            """, unsafe_allow_html=True)
        
        with col2:
            st.markdown(f"""
            **SACKOFF**  
            **{metricas['sackoff_total']:.2f}%**  
            <span style='color: #1C8074;'>üìâ</span>
            """, unsafe_allow_html=True)
        
        with col3:
            st.markdown(f"""
            **DURABILIDAD**  
            **{metricas['durabilidad_promedio']:.1f}%**  
            <span style='color: #1C8074;'>üìä</span>
            """, unsafe_allow_html=True)
        
        st.markdown("---")
        
        # Comportamiento semanal
        st.subheader("Comportamiento semanal")
        
        # An√°lisis de Producci√≥n
        with st.expander("üìà An√°lisis de Producci√≥n", expanded=True):
            st.write(report['analisis_produccion'])
            
            # Mostrar gr√°fico de sackoff por semana con y sin Adiflow si est√° disponible
            if 'graficos' in report and 'sackoff_adiflow' in report['graficos']:
                st.subheader("Tendencia del Sackoff por Semana: Con vs Sin Adiflow")
                st.plotly_chart(report['graficos']['sackoff_adiflow'], use_container_width=True)
                
                # Agregar explicaci√≥n de la gr√°fica
                st.info("""
                **Interpretaci√≥n de la gr√°fica:**
                - **L√≠nea verde**: Sackoff semanal cuando se usa Adiflow
                - **L√≠nea gris**: Sackoff semanal cuando NO se usa Adiflow  
                - **L√≠nea punteada**: Nivel √≥ptimo de sackoff (-0.3%)
                - **Eje X**: Rango de fechas de cada semana (dd/mm - dd/mm)
                - **Objetivo**: Mantener el sackoff semanal en -0.3% o superior para optimizar la producci√≥n
                """)
            
            # Mostrar gr√°fico de toneladas por semana con y sin Adiflow si est√° disponible
            if 'graficos' in report and 'toneladas_adiflow' in report['graficos']:
                st.subheader("Tendencia de Toneladas Producidas por Semana: Con vs Sin Adiflow")
                st.plotly_chart(report['graficos']['toneladas_adiflow'], use_container_width=True)
                
                # Agregar explicaci√≥n de la gr√°fica
                st.info("""
                **Interpretaci√≥n de la gr√°fica:**
                - **L√≠nea verde**: Toneladas semanales cuando se usa Adiflow
                - **L√≠nea gris**: Toneladas semanales cuando NO se usa Adiflow  
                - **L√≠nea punteada**: Promedio semanal total como referencia
                - **Eje X**: Rango de fechas de cada semana (dd/mm - dd/mm)
                - **Objetivo**: Identificar el impacto del Adiflow en el volumen de producci√≥n semanal
                """)
            

        
        # An√°lisis de Calidad
        with st.expander("üîç An√°lisis de Calidad", expanded=True):
            st.write(report['analisis_calidad'])
            
            # Mostrar gr√°fico de calidad si est√° disponible
            if 'graficos' in report and 'calidad' in report['graficos']:
                st.plotly_chart(report['graficos']['calidad'], use_container_width=True)
        
        # An√°lisis de Sackoff vs Dosis de Agua
        with st.expander("üíß Sackoff vs Dosis de Agua: Con vs Sin Adiflow", expanded=True):
            # Mostrar gr√°fico de sackoff vs dosis de agua si est√° disponible
            if 'graficos' in report and 'sackoff_agua' in report['graficos']:
                st.plotly_chart(report['graficos']['sackoff_agua'], use_container_width=True)
                
                # Agregar explicaci√≥n de la gr√°fica
                st.info("""
                **Interpretaci√≥n de la gr√°fica:**
                - **Puntos verdes**: √ìrdenes con Adiflow (sackoff vs peso de agua)
                - **Puntos grises**: √ìrdenes sin Adiflow (sackoff vs peso de agua)
                - **L√≠nea punteada**: Nivel √≥ptimo de sackoff (-0.3%)
                - **Eje X**: Peso de agua utilizado (kg)
                - **Eje Y**: Sackoff por orden de producci√≥n (%)
                - **Objetivo**: Identificar la relaci√≥n entre dosis de agua y p√©rdidas de producci√≥n
                """)
            
            # Mostrar an√°lisis de relaci√≥n entre sackoff y dosis de agua
            if 'sackoff_agua_analysis' in report and report['sackoff_agua_analysis']['has_analysis']:
                analysis = report['sackoff_agua_analysis']
                
                st.subheader("üìä An√°lisis de Relaci√≥n: Sackoff vs Dosis de Agua")
                
                col1, col2 = st.columns(2)
                
                with col1:
                    st.metric(
                        label="Sackoff Promedio (>500kg agua)",
                        value=f"{analysis['sackoff_alto_agua']:.2f}%",
                        delta=f"{analysis['sackoff_alto_agua'] - analysis['sackoff_bajo_agua']:.2f}% vs ‚â§500kg"
                    )
                    
                    st.metric(
                        label="√ìrdenes con >500kg agua",
                        value=f"{analysis['total_alto_agua']}",
                        delta=f"{analysis['sackoff_cerca_cero_alto']} cerca de cero"
                    )
                
                with col2:
                    st.metric(
                        label="Sackoff Promedio (‚â§500kg agua)",
                        value=f"{analysis['sackoff_bajo_agua']:.2f}%"
                    )
                    
                    st.metric(
                        label="% √ìrdenes cerca de cero (>500kg)",
                        value=f"{analysis['porcentaje_cerca_cero']:.1f}%"
                    )
                
                # Mostrar conclusi√≥n del an√°lisis
                if analysis['tiene_tendencia_cerca_cero']:
                    st.success(f"""
                    **üéØ Hallazgo Clave:** 
                    Las √≥rdenes de producci√≥n con m√°s de 500kg de agua tienden a tener un sackoff cercano a cero 
                    ({analysis['porcentaje_cerca_cero']:.1f}% de las √≥rdenes con >500kg tienen sackoff entre -0.5% y +0.5%).
                    
                    **üìà Implicaci√≥n:** Esta tendencia sugiere que dosis de agua superiores a 500kg pueden optimizar 
                    el proceso de peletizaci√≥n, reduciendo las p√©rdidas de producci√≥n.
                    """)
                else:
                    st.info(f"""
                    **üìä An√°lisis de Dosis de Agua:**
                    Se analizaron {analysis['total_alto_agua']} √≥rdenes con m√°s de 500kg de agua.
                    El {analysis['porcentaje_cerca_cero']:.1f}% de estas √≥rdenes tienen sackoff cercano a cero.
                    
                    **üí° Observaci√≥n:** Aunque no se detecta una tendencia clara, se recomienda monitorear 
                    continuamente la relaci√≥n entre dosis de agua y sackoff para optimizar los procesos.
                    """)
                
                # Mostrar estad√≠sticas detalladas por rango
                if 'stats_por_rango' in analysis:
                    st.subheader("üìã Estad√≠sticas por Rango de Peso de Agua")
                    
                    # Crear tabla de estad√≠sticas
                    stats_data = []
                    for rango, stats in analysis['stats_por_rango'].items():
                        if 'sackoff_por_orden_produccion' in stats:
                            stats_data.append({
                                'Rango': rango,
                                'Sackoff Promedio (%)': f"{stats['sackoff_por_orden_produccion']['mean']:.2f}",
                                'Desv. Est√°ndar': f"{stats['sackoff_por_orden_produccion']['std']:.2f}",
                                'N√∫mero de √ìrdenes': stats['sackoff_por_orden_produccion']['count']
                            })
                    
                    if stats_data:
                        st.dataframe(
                            pd.DataFrame(stats_data),
                            use_container_width=True,
                            hide_index=True
                        )
            else:
                st.warning("No hay suficientes datos para realizar el an√°lisis de relaci√≥n entre sackoff y dosis de agua.")
        
        
        # Correlaciones
        if 'correlaciones' in report and report['correlaciones']:
            st.subheader("üîó An√°lisis de Correlaciones")
            
            for corr in report['correlaciones']:
                with st.expander(f"üîç {corr['factor']}", expanded=True):
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.write(f"**Factor:** {corr['factor']}")
                        if 'correlacion' in corr:
                            st.write(f"**Correlaci√≥n:** {corr['correlacion']}")
                        st.write(f"**Impacto:** {corr['impacto']}")
                    
                    with col2:
                        st.write(f"**Descripci√≥n:** {corr['descripcion']}")
                    
                    # Indicador visual del impacto
                    if corr['impacto'] == 'positivo':
                        st.success("‚úÖ Impacto Positivo")
                    elif corr['impacto'] == 'negativo':
                        st.error("‚ùå Impacto Negativo")
                    else:
                        st.info("‚ÑπÔ∏è Impacto Bajo")
        
        # Recomendaciones
        st.subheader("üí° Recomendaciones")
        
        for i, rec in enumerate(report['recomendaciones'], 1):
            st.write(f"**{i}.** {rec}")

def generate_pdf_report(report: Dict) -> bytes:
    """Genera un PDF del informe con colores corporativos e im√°genes de gr√°ficos"""
    from reportlab.lib.pagesizes import letter, A4
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, Image
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import inch
    from reportlab.lib import colors
    from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT
    import io
    import tempfile
    import os
    from config import config
    
    # Crear buffer para el PDF
    buffer = io.BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=72, leftMargin=72, topMargin=72, bottomMargin=72)
    
    # Definir colores corporativos exactos del prompt
    corporate_colors = {
        'primary': '#1C8074',      # PANTONE 3295 U
        'secondary': '#666666',    # PANTONE 426 U
        'accent': '#1A494C',       # PANTONE 175-16 U
        'accent2': '#94AF92',      # PANTONE 7494 U
        'light': '#E6ECD8',        # PANTONE 152-2 U
        'gray': '#C9C9C9'          # PANTONE COLOR GRAY 2 U
    }
    
    # Convertir colores hex a RGB
    def hex_to_rgb(hex_color):
        hex_color = hex_color.lstrip('#')
        return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
    
    # Funci√≥n para convertir gr√°fico de Plotly a imagen
    def plotly_to_image(fig, filename):
        """Convierte un gr√°fico de Plotly a imagen PNG"""
        try:
            # Crear directorio temporal si no existe
            temp_dir = "temp_images"
            if not os.path.exists(temp_dir):
                os.makedirs(temp_dir)
            
            # Guardar gr√°fico como imagen
            img_path = os.path.join(temp_dir, filename)
            fig.write_image(img_path, width=800, height=400, scale=1)
            return img_path
        except Exception as e:
            print(f"Error guardando gr√°fico: {e}")
            return None
    
    # Estilos personalizados con colores corporativos
    styles = getSampleStyleSheet()
    
    # T√≠tulo principal
    title_style = ParagraphStyle(
        'CorporateTitle',
        parent=styles['Heading1'],
        fontSize=24,
        textColor=colors.HexColor(corporate_colors['primary']),
        alignment=TA_CENTER,
        spaceAfter=30
    )
    
    # Subt√≠tulos
    subtitle_style = ParagraphStyle(
        'CorporateSubtitle',
        parent=styles['Heading2'],
        fontSize=16,
        textColor=colors.HexColor(corporate_colors['accent']),
        spaceAfter=12,
        spaceBefore=20
    )
    
    # Texto normal
    normal_style = ParagraphStyle(
        'CorporateNormal',
        parent=styles['Normal'],
        fontSize=11,
        textColor=colors.HexColor(corporate_colors['accent']),
        spaceAfter=6
    )
    
    # Contenido del PDF
    story = []
    
    # T√≠tulo
    story.append(Paragraph("üìä Informe Detallado de Producci√≥n", title_style))
    story.append(Spacer(1, 20))
    
    # Fecha de generaci√≥n
    story.append(Paragraph(f"Generado el: {datetime.now().strftime('%d/%m/%Y %H:%M')}", normal_style))
    story.append(Spacer(1, 20))
    
    # Resumen Ejecutivo
    story.append(Paragraph("üìã Resumen Ejecutivo", subtitle_style))
    story.append(Paragraph(report['resumen_ejecutivo'], normal_style))
    story.append(Spacer(1, 15))
    
    # M√©tricas Clave
    story.append(Paragraph("üìä KPIs Principales", subtitle_style))
    
    metricas = report['metricas_clave']
    kpi_data = [
        ['M√©trica', 'Valor'],
        ['Diferencia de Toneladas', f"{metricas['diferencia_toneladas']:.1f} ton"],
        ['Sackoff Total', f"{metricas['sackoff_total']:.2f}%"],
        ['Durabilidad Promedio', f"{metricas['durabilidad_promedio']:.1f}%"],
        ['Dureza Promedio', f"{metricas['dureza_promedio']:.1f}%"],
        ['Finos Promedio', f"{metricas['finos_promedio']:.1f}%"],
        ['Total √ìrdenes', str(metricas.get('total_ordenes', 'N/A'))],
        ['Productos √önicos', str(metricas.get('productos_unicos', 'N/A'))],
        ['Plantas Activas', str(metricas.get('plantas_activas', 'N/A'))]
    ]
    
    kpi_table = Table(kpi_data, colWidths=[2*inch, 1.5*inch])
    kpi_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor(corporate_colors['primary'])),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 12),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.HexColor(corporate_colors['light'])),
        ('GRID', (0, 0), (-1, -1), 1, colors.HexColor(corporate_colors['gray'])),
        ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
        ('FONTSIZE', (0, 1), (-1, -1), 10),
    ]))
    
    story.append(kpi_table)
    story.append(Spacer(1, 20))
    
    # An√°lisis de Producci√≥n con gr√°fico
    story.append(Paragraph("üìà An√°lisis de Producci√≥n", subtitle_style))
    story.append(Paragraph(report['analisis_produccion'], normal_style))
    story.append(Spacer(1, 10))
    
    # Incluir gr√°fico de producci√≥n si est√° disponible
    if 'graficos' in report and 'produccion' in report['graficos']:
        try:
            fig = report['graficos']['produccion']
            img_path = plotly_to_image(fig, 'produccion_chart.png')
            if img_path and os.path.exists(img_path):
                img = Image(img_path, width=6*inch, height=3*inch)
                story.append(img)
                story.append(Spacer(1, 10))
        except Exception as e:
            print(f"Error incluyendo gr√°fico de producci√≥n: {e}")
    
    # An√°lisis de Calidad con gr√°fico
    story.append(Paragraph("üîç An√°lisis de Calidad", subtitle_style))
    story.append(Paragraph(report['analisis_calidad'], normal_style))
    story.append(Spacer(1, 10))
    
    # Incluir gr√°fico de calidad si est√° disponible
    if 'graficos' in report and 'calidad' in report['graficos']:
        try:
            fig = report['graficos']['calidad']
            img_path = plotly_to_image(fig, 'calidad_chart.png')
            if img_path and os.path.exists(img_path):
                img = Image(img_path, width=6*inch, height=3*inch)
                story.append(img)
                story.append(Spacer(1, 10))
        except Exception as e:
            print(f"Error incluyendo gr√°fico de calidad: {e}")
    
    # An√°lisis de Diferencia de Toneladas con gr√°fico
    story.append(Paragraph("‚ö° An√°lisis de Diferencia de Toneladas", subtitle_style))
    story.append(Paragraph(report['analisis_diferencia_toneladas'], normal_style))
    story.append(Spacer(1, 10))
    
    # Incluir gr√°fico de diferencia de toneladas si est√° disponible
    if 'graficos' in report and 'diferencia_toneladas' in report['graficos']:
        try:
            fig = report['graficos']['diferencia_toneladas']
            img_path = plotly_to_image(fig, 'diferencia_toneladas_chart.png')
            if img_path and os.path.exists(img_path):
                img = Image(img_path, width=6*inch, height=3*inch)
                story.append(img)
                story.append(Spacer(1, 10))
        except Exception as e:
            print(f"Error incluyendo gr√°fico de diferencia de toneladas: {e}")
    
    # Comparaciones Temporales
    if 'comparaciones_temporales' in report and report['comparaciones_temporales']['mes_actual_vs_anterior']:
        story.append(Paragraph("üìÖ Comparaciones Temporales", subtitle_style))
        
        comparisons = report['comparaciones_temporales']['mes_actual_vs_anterior']
        comp_data = [['M√©trica', 'Mes Actual', 'Mes Anterior', 'Cambio', 'Tendencia']]
        
        for metric, data in comparisons.items():
            comp_data.append([
                metric.replace('_', ' ').title(),
                f"{data['actual']:.2f}",
                f"{data['anterior']:.2f}",
                data['cambio_pct'],
                data['tendencia']
            ])
        
        comp_table = Table(comp_data, colWidths=[1.5*inch, 1*inch, 1*inch, 1*inch, 1*inch])
        comp_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor(corporate_colors['accent'])),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 10),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), colors.HexColor(corporate_colors['light'])),
            ('GRID', (0, 0), (-1, -1), 1, colors.HexColor(corporate_colors['gray'])),
            ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 1), (-1, -1), 9),
        ]))
        
        story.append(comp_table)
        story.append(Spacer(1, 20))
    
    # Correlaciones
    if 'correlaciones' in report and report['correlaciones']:
        story.append(Paragraph("üîó An√°lisis de Correlaciones", subtitle_style))
        
        for corr in report['correlaciones']:
            story.append(Paragraph(f"‚Ä¢ {corr['factor']}: {corr['descripcion']}", normal_style))
        
        story.append(Spacer(1, 15))
    
    # Recomendaciones
    story.append(Paragraph("üí° Recomendaciones", subtitle_style))
    for i, rec in enumerate(report['recomendaciones'], 1):
        story.append(Paragraph(f"{i}. {rec}", normal_style))
    
    story.append(Spacer(1, 15))
    

    
    # Generar PDF
    doc.build(story)
    buffer.seek(0)
    
    # Limpiar archivos temporales
    try:
        temp_dir = "temp_images"
        if os.path.exists(temp_dir):
            for file in os.listdir(temp_dir):
                if file.endswith('.png'):
                    os.remove(os.path.join(temp_dir, file))
    except Exception as e:
        print(f"Error limpiando archivos temporales: {e}")
    
    return buffer.getvalue() 